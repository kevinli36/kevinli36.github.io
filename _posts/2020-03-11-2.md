---
layout:     post
title:      春招面试经历
subtitle:   VIVO | 4399 | 华智融 | 腾达
date:       2020-03-11
author:     Kevin
header-img: img/post-bg-desk.jpg
catalog: true
tags:
    - 面试
    - Vivo
    - 4399
    - 华智融
    - 腾达
---

# VIVO

## 面试时间 
* 2020-03-11 10:00 - 10:30 微信视频面试

## 面试岗位
* Java工程师(Android方向)

## 面试经验

### Linux如何实现线程通信
对于同一个进程下的不同线程，由于这些线程之间共享，它们之间的通信不需要特别的手段。而对于不同进程下的线程来说，它们之间的通信其实等同于进程间通信。
* 同进程，不同线程: 不同线程共享同一数据结构和同一内存控件，它们之间的通信不需要特别的手段，使用全局变量即可实现。这种情况下需要注意的是，如何进行线程之间的同步，来避免因线程执行时序不同而带来的问题。
* 同进程下不同线程之间的同步: 可通过互斥锁，条件变量和信号量实现。
    * 互斥锁: 线程在访问共享资源前对互斥锁进行加锁操作，加锁之后，任何其他试图加锁的线程将被阻塞，直到当前线程释放该锁。当一个互斥锁被释放之后，所有被阻塞在该锁上的线程都将编程可执行状态，直到第一个变成运行状态的线程完成加锁操作，其他线程再次被阻塞。
    * 互斥量的死锁: 死锁的产生有4个必要条件，一是互斥条件，即一段时间内某竞争资源仅被一个线程所拥有; 二是请求和保持条件，即当线程因请求资源而阻塞时，对已有的资源保持不释放; 三是不剥夺条件，即线程已拥有的资源在使用完之前不可剥夺，只有当线程使用结束后该资源才得到释放; 最后是环路等待，即当发生死锁时，必然存在一个资源-线程的环形链。
    * 如何避免死锁: 可以通过破坏死锁的4个必要条件来预防和解锁死锁。例如，一次性分配所有资源，这样就不会有请求，即破化了请求条件; 当线程的某一种资源得不到分配时，则不给这个线程分配资源，即破坏请求和保持条件; 当线程得到了部分资源又因请求其他资源而阻塞时，释放其拥有的资源，即破坏不剥夺条件; 或者给所有资源编号，线程按照编号大小顺序依次请求资源，即破坏环路等待条件。除此之外，还可以通过超时放弃(等待超时则释放所有资源，解开之前的锁)，或者改变加锁顺序的方式(银行家算法)来避免死锁。
    * 银行家算法: 首先需要定义状态和安全状态的概念。系统的状态是当前给线程分配的资源情况。因此，状态包含两个向量——Resource(系统中每种资源的总量)和Available(未分配给线程的每种资源的总量)及两个矩阵——Claim(表示线程对资源的需求)和Allocation(表示当前分配给线程的资源)。安全状态是指至少有一个资源分配序列不会导致死锁。当线程请求一组资源时，假设同意该请求，从而改变了系统的状态，然后确定其结果是否还处于安全状态。如果是，同意这个请求; 如果不是，阻塞该线程直到同意该请求后系统状态仍然是安全的。
    * 读写锁: 互斥锁升级版，互斥锁只有锁和解锁两种状态，而读写锁则有读锁定，写锁定和解锁三种状态。一次只能有一个线程占有写锁定，但可以有多个线程占有读锁定。换言之，当读写锁处于写锁定状态时，其他试图加锁的线程将被阻塞; 而当读写锁处于读锁定状态时，试图以写模式加锁的线程将被阻塞，而试图以读模式加锁的线程可以正常访问。
    * 条件变量: 用于线程间同步，与互斥量一同使用。由于互斥量只有锁和解锁两种状态，当事件复杂时，需要引入其他条件来判断线程是否被阻塞，因此加入了条件变量。条件变量本身由互斥量保护，在判断条件变量前先加锁，之后判断是否满足条件(pthread_cond_wait())，如果不满足被阻塞，则锁被解除，允许其他线程改变条件。改变条件变量前同样先加锁，之后改变条件变量，最后解锁，同时唤醒其他被该条件变量阻塞的线程，其他被阻塞的线程在加锁后判断条件是否满足，不满足则继续等待。
    * 信号量: 一个非负的整数计数器，用来控制公共资源，当线程请求公共资源时，如果信号量为0，则该线程被阻塞，如果>0，则信号量减少，线程继续执行，执行完之后释放资源，信号量增加。如果只控制一个公共资源，即信号量只有1/0两种状态，那么信号量也可以模拟互斥量的功能。
* 不同进程，不同线程: 等同于进程间通信。Linux进程间通信(IPC，InterProcess Communication)主要继承Unix的进程通信方式，通过管道、信号/信号量、消息队列、共享内存以及套接字方式实现。
    * 管道: 又可分为管道(Pipe)、流管道(S_Pipe)和命名管道(Name_pipe)。管道只能在具有亲缘关系的进程间使用(父子进程)，且数据只能单向流动; 流管道允许数据双向传输; 命名管道则赋予管道名字，允许无亲缘关系的进程之间互相通信。
    * 信号/信号量: 信号量一般用于同一进程下的不同线程以及不同进程间的同步，用于控制进程/线程对共享资源的访问。信号用于通知接收信号的进程有某种事件发生，可用于进程间通信，也可发送信号给自身。信号和信号量均无法传递复杂信息。
    * 消息队列: 由消息组成的链表，容量受系统限制，克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限的缺点。
    * 共享内存: 最快的IPC形式，针对其他进程间通行方式运行效率低而设计，但需要另外的同步手段(如信号量)控制各进程对共享内存的访问。
    * 套接字: 可用于不同机器间的进程通信。

### C/C++在main()执行前会进行什么操作，如何验证
当一个C/C++程序完成编译，链接至可执行文件时，链接器将选择正确的C/C++运行库启动函数。所有的C/C++运行库启动函数所作的事情都是一样的，区别在于处理字符串的类型(ANSI或Unicode)和调用的入口点函数不同(glibc是_start，MSVC是mainCRTStartup)。启动函数将会进行以下几个步骤:
* 获取新进程完整命令行的指针
* 获取指向新进程环境变量的指针
* 初始化C/C++运行库的全局变量
* 初始化C运行库内存分配函数(malloc和calloc)和其他底层I/O例程使用的堆
* 调用所有全局和静态C++类对象的构造函数

当入口函数返回后，启动函数将调用C运行库函数exit，该函数将进行以下几个步骤:
* 调用_onexit函数所调用注册的所有函数(后进先出)
* 调用所有全局和静态C++类对象的析构函数
* 在DEBUG生成中，如果设置了_CRTDBG_LEAK_CHECK_DF标志，就通过调用_CrtDumpMemoryLeaks函数生成内存泄露报告。
* 调用操作系统的ExitProcess函数，向其传入nMainRetVal。这会导致操作系统杀死我们的进程，并设置它的退出代码

下面是一个测试程序
```
#include <iostream>
#include <cstdlib>

using namespace std;

class simpleclass{
public:
    simpleclass(){
        cout << "simpleclass construct" << endl;
    }

    ~simpleclass(){
        cout << "simpleclass destruct" << endl;
    }
};

int func1(){
    cout << "func1" << endl;
    return 0;
}

int func2(){
    cout << "func2" << endl;
    return 0;
}

int func3(){
    cout << "func3" << endl;
    return 0;
}

int func4(){
    cout << "func4" << endl;
    return 0;
}

simpleclass simpleclass1;

int main(){
    _onexit(func1);
    _onexit(func2);
    _onexit(func3);
    _onexit(func4);
    cout << "main" << endl;
}
```

该程序的输出结果为
```
simpleclass construct
main
func4
func3
func2
func1
simpleclass destruct
```

该结果显然验证了上述说明中main函数执行前步骤的第5条以及执行后步骤的第1条和第2条。

### C/C++常量指针和指针常量的区别与用法
* 指针常量(const pointer) `int * const p`，即类型为指针的常量，地址不可改变，但地址中的值可改变
* 常量指针(pointer to const) `const int* p`，即指向常量的指针，指向的值不可通过指针改变，但指针可指向其他值

### 宏定义与全局变量的区别
* 宏定义在程序预处理期间被替换，程序不为其分配内存，本身无变量类型，仅是字符串替换，定义后值不可改变，仅在被定义的文件，或引用该文件的文件中使用（换言之，不支持extern修饰）。
* 全局变量在程序运行期间处理，需要程序为其分配内存，本身具有变量类型，定义后值可在运行中被修改，支持extern修饰，在工程所有文件中被声明后即可使用。

### 嵌入式开发中`extern C`的作用
`extern C`的作用主要是为了解决C++与C之间相互调用的问题。在C++中，为了支持重载机制，在编译生成的汇编码中，要对函数的名字进行一些处理，加入比如函数的返回类型等等。而在C中，只是简单的函数名字而已，不会加入其他的信息。为了在C++中调用C文件的函数，需要在.h文件中加入`extern C`，表明该函数以C的方式进行编译。

### TCP三次握手，哪一方先进入Link状态？讲一下TCP字节流控制
TCP三次握手中，客户端先进入Link(ESTABLISHED)状态。在服务端发送ACK响应，客户端接收后，即第二次握手后，客户端进入ESTABLISHED状态。第三次握手后，服务端进入ESTABLISHED状态。

TCP是全双工传输，即客户端和服务端两方可互相发送数据，都有发送缓冲和接受缓冲。发送缓冲中保留的是应用层的发送方程序向运输层传输的还未发送的数据，以及发送了还未收到确认的数据。接收缓冲中保留的是已接受但还未交付给接收方程序的数据，以及未按序收到的数据。

TCP通过报文中的ACK确认字段来保证数据传输的有序性。接收方接收数据后，向发送方报送确认报文，报文中的ACK=最后一个按序收到的字节序号+1，表明ACK之前的数据已按序接收，期望接收到从ACK开始的字节数据。发送方接收到确认报文后，修改发送窗口的大小，不再保留ACK之前的数据，从ACK开始发送新的字节数据。

当没有收到确认时，发送方需要保存已发送的数据，以便在超时时进行重传。而对于接收方，当收到的数据是无序时，也不可将数据交付给应用层。

---

# 4399

## 面试时间
* 2020-05-13 14：40 - 15:10 电话面试

## 面试岗位
* 游戏后端开发工程师

## 面试经验

* 过去在学校有过什么项目经验？遇到了什么难点？如何解决？
* 服务端编程是否有接触过
* 对投递的岗位了解吗
* 未来的职业规划
* 接触过数据库吗？数据库的维护一般怎么做

### 简述一下C++模板的使用
C++模板是C++实现参数多态化的一种工具，目的是方便用户对函数或类声明一种一般模式，使得程序员可以编写与变量类型无关的代码。如`template <class T> swap(T &a, T &b)`

### 重载和重写的区别
重载指在可对语义、功能相似的函数用同名函数表示，函数的参数、返回值可能不同。重载的各函数作用范围相同，函数的参数不同（变量类型、顺序等），函数名相同，virtual关键字可有可无。

重写指子类覆盖父类的函数，函数的作用范围不同，函数名相同，参数相同，父类函数必须有virtual关键字。此时父类一般作为接口类被继承，父类的函数多为纯虚函数，函数功能的实现交由继承接口的子类完成。

---

# 华智融

## 面试时间
* 2020-05-13 16：30 - 17:40 微信视频面试

## 面试岗位
* 嵌入式开发工程师

## 面试经验

* 先笔试，笔试题均为C++语法题
* 做过的项目及难点
* 未来职业规划
* 了解socket编程吗
* 了解Linux吗

### TCP三次握手和四次挥手
TCP的三次握手发生在TCP建立连接的过程中，准确一点讲应是一次握手，3次报文。在握手开始之间，客户端和服务端都先建立自己的TCB（传输控制模块），初始化发送和接收缓冲。客户端首先对服务端发送请求连接建立的报文，服务点接收后向客户端发送确认报文，客户端接收到确认报文后，进入ESTABLISHED状态，再向服务端发送确认报文。服务端接收到确认报文后，也进入ESTABLISHED状态，TCP连接成功建立。

客户端的确认报文，主要是为了避免以下情况：如果不设置客户端的确认报文，当客户端发送第一次请求建立连接的报文后，由于一些故障，客户端应用程序关闭；而服务端在发送确认报文后，建立与客户端的连接，一直等待客户端的数据，浪费了服务端的资源。

TCP四次挥手发生在TCP结束连接的过程中，准确一点讲应是一次挥手，4次报文。以客户端请求断开连接为例，客户端向服务端发送连接结束报文，服务端接收后向客户端发送确认报文。客户端接收到该确认报文后，客户端向服务端方向的TCP连接就已断开，TCP连接进入"半关闭"状态，但服务端此时可能还需要向客户端发送一些数据。当服务端完成所有的数据发送后，服务端向客户端发送连接结束报文，客户端接收后向服务端发送确认报文，同时自身进入TIME-WAIT状态。服务端接收到确认报文后，立即退出连接，而客户端在进入TIME-WAIT状态后，需要等待2个MSL（最长报文段寿命）时间，之后退出连接。

TIME-WAIT状态主要是为了预防客户端最后一次确认报文丢失。此时服务端未结束连接，当连接结束报文超时时，会进行重传。若客户端在发送了确认报文后立即关闭，则无法接收该重传报文，也无法再次发送确认连接结束的报文，服务端就无法正常关闭TCP连接。

### 线程和进程的区别
进程是操作系统分配资源的基本单位，线程是处理机进行调度和执行的基本单位。相比与进程切换，线程的切换具有更小的系统开销，因此也被称为轻量级进程。同一个进程下的线程共享进程的堆空间以及方法区资源（如全局变量），各线程拥有自己独立的栈空间和程序计数器。当一个线程崩溃时，该线程所处的进程也随之崩溃，而该进程下的其他线程也会终止；而一个进程崩溃时，与之不相关的进程可正常运行。

### 堆和栈的区别
* 堆(heap)：由程序员主动分配和释放，程序结束时可能由OS进行回收。
* 栈(stack)：由编译器自动分配和释放，存放函数的参数、局部变量等，程序结束时自动回收。

### 中断有哪几种？中断处理函数中可以有延时操作吗？
中断指当出现需要时，CPU暂时停止当前程序的执行转而执行处理新情况的程序和执行过程。按照不同的角度，中断有以下几种分类。
* 同步/异步：同步中断指由CPU主动执行，并由CPU控制的中断，又称异常，如故障，陷阱和终止。异步中断指由外设电信号引起的，CPU不知道何时来临的中断，又称中断。
* 硬中断/软中断：硬中断指由硬件产生的中断，可直接中断CPU，也可中断软中断。软中断由当前进程产生，通常是IO请求，仅与内核联系，与硬件无关，不可中断CPU。
* 按照引起中断的外设分，常见的有定时器中断，串口中断以及外部中断（如IO口中断、RTC时钟中断等）。

中断处理函数中不能使用有睡眠功能的函数，因为中断程序不是进程，没有进程的概念，也不存在休眠的概念。如果需要在中断中进行延时操作，可以使用忙等待函数代替，其本质是根据CPU频率进行一定次数的循环。对于Linux内核，不要使用for/while的空循环，因为内核处理这种循环的速度很快，无法达到延时的效果。这与裸板程序的延时操作有所不同，需要注意。

### I2C支持一对多的数据传输吗？
I2C同一时间仅支持一对一通信，一对多需要进行分时操作，新的主从设备需要等待当前主从设备通信完毕，I2C总线空闲后才能开启传输。

---

# 腾达

## 面试时间
* 2020-05-15 10：30 - 11:30 微信视频面试

## 面试岗位
* 嵌入式开发工程师

## 面试经验

* 做过的项目及难点，项目问的比较细致
* 做过的最有价值，最有成就感的事情，如何完成的
* 对于新的技术应该如何去学习掌握

### TCP三次握手，OSI 7层协议
TCP三次握手过程见上。OSI 7层协议从上至下依次是应用层，表示层，会话层，运输层，网络层，物理层和数据链路层。

### Linux终端命令行指令
* man / help: 查看命令帮助
* ls: 列出目录内容及其内容属性信息
    * -a: 显示隐藏文件
    * 
* cd: 从当前目录切换到指定目录
    * ..: 返回上一级目录

* cp: 复制文件或目录
* find: 查找目录下的文件
* mkdir: 创建目录
* mv: 重命名或移动文件
* pwd: 希纳是当前工作目录的绝对路径
* rm: 删除文件或目录
* touch: 创建新文件或改变已有文件的时间戳属性
* cat: 连接多个文件并打印到品目输出或重定向到指定文件
* head/tail: 显示文件的头部/尾部
* vi/vim: 命令行文本编辑器
* tar/zip/unzip: 打包压缩/解压缩
* chmod: 改变文件/目录权限
* ps: 显示运行的进程
    * -A: 显示所有的进程
    * a: 显示终端中包括其他用户的所有进程
    * | grep xx: 根据xx查找进程
* kill: 杀死进程

### C语言包含库文件有""和<>两种方式，有什么区别
`#include <>`和`#include ""`都会在实现定义的位置查找文件，并将其包含。区别是若`#include ""`查找成功，则遮蔽`#include <>`所能找到的同名文件；否则再按照`#include <>`的方式查找文件。另外标准库头文件都放在`#include <>`所查找的位置。

使用`#include ""`包含文件，系统优先在当前目录下寻找，找不到再去系统目录中寻找。而`#include <>`则正好相反。使用中，对于标准头文件如`stdio.h、stdlib.h`等一般使用`#include <>`包含，而自定义的头文件则使用`#include ""`包含。

### 简述一下预编译
* C语言源程序生成代码的各阶段为: C源程序 -> 编译预处理 -> 编译 -> 优化程序 -> 汇编程序 -> 链接程序 -> 可执行文件。其中编译预处理，也称预编译阶段，是先于编译对源程序进行初步的转换，包括伪指令（以#开头的指令）和特殊符号等，并且删除程序的注释和多余的空白字符，之后将新的源代码提供给编译器。

* 伪指令主要包括宏定义、条件编译和头文件包含三种。除此之外还有`#error`，使编译器显示一条错误信息，然后停止编译；`#line`，改变`__LINE__`与`__FILE__`的内容；`#pragma`，没有正式的定义，编译器可以自定义其用途，典型的用法是禁止或允许某些警告信息。

* 常见的特殊符号有以下几种:
```
__FILE__ 包含当前程序文件名的字符串
__LINE__  表示当前行号的整数
__DATE__ 包含当前日期的字符串
__STDC__  如果编译器遵循ANSI C标准，它就是个非零值
__TIME__ 包含当前时间的字符串
```