---
layout:     post
title:      Vivo 面试经历
subtitle:   Java工程师(Android方向)面试经验
date:       2020-03-11
author:     Kevin
header-img: img/post-bg-desk.jpg
catalog: true
tags:
    - 面试
    - Vivo
---

## 面试时间 
* 03-11 10:00 - 10:30

## 面试岗位
* Java工程师(Android方向)

## 面试经验

### Linux如何实现线程通信
对于同一个进程下的不同线程，由于这些线程之间共享，它们之间的通信不需要特别的手段。而对于不同进程下的线程来说，它们之间的通信其实等同于进程间通信。
* 同进程，不同线程: 不同线程共享同一数据结构和同一内存控件，它们之间的通信不需要特别的手段，使用全局变量即可实现。这种情况下需要注意的是，如何进行线程之间的同步，来避免因线程执行时序不同而带来的问题。
* 同进程下不同线程之间的同步: 可通过互斥锁，条件变量和信号量实现。
    * 互斥锁: 线程在访问共享资源前对互斥锁进行加锁操作，加锁之后，任何其他试图加锁的线程将被阻塞，直到当前线程释放该锁。当一个互斥锁被释放之后，所有被阻塞在该锁上的线程都将编程可执行状态，直到第一个变成运行状态的线程完成加锁操作，其他线程再次被阻塞。
    * 互斥量的死锁: 死锁的产生有4个必要条件，一是互斥条件，即一段时间内某竞争资源仅被一个线程所拥有; 二是请求和保持条件，即当线程因请求资源而阻塞时，对已有的资源保持不释放; 三是不剥夺条件，即线程已拥有的资源在使用完之前不可剥夺，只有当线程使用结束后该资源才得到释放; 最后是环路等待，即当发生死锁时，必然存在一个资源-线程的环形链。
    * 如何避免死锁: 可以通过破坏死锁的4个必要条件来预防和解锁死锁。例如，一次性分配所有资源，这样就不会有请求，即破化了请求条件; 当线程的某一种资源得不到分配时，则不给这个线程分配资源，即破坏请求和保持条件; 当线程得到了部分资源又因请求其他资源而阻塞时，释放其拥有的资源，即破坏不剥夺条件; 或者给所有资源编号，线程按照编号大小顺序依次请求资源，即破坏环路等待条件。除此之外，还可以通过超时放弃(等待超时则释放所有资源，解开之前的锁)，或者改变加锁顺序的方式(银行家算法)来避免死锁。
    * 银行家算法: 首先需要定义状态和安全状态的概念。系统的状态是当前给线程分配的资源情况。因此，状态包含两个向量——Resource(系统中每种资源的总量)和Available(未分配给线程的每种资源的总量)及两个矩阵——Claim(表示线程对资源的需求)和Allocation(表示当前分配给线程的资源)。安全状态是指至少有一个资源分配序列不会导致死锁。当线程请求一组资源时，假设同意该请求，从而改变了系统的状态，然后确定其结果是否还处于安全状态。如果是，同意这个请求; 如果不是，阻塞该线程直到同意该请求后系统状态仍然是安全的。
    * 读写锁: 互斥锁升级版，互斥锁只有锁和解锁两种状态，而读写锁则有读锁定，写锁定和解锁三种状态。一次只能有一个线程占有写锁定，但可以有多个线程占有读锁定。换言之，当读写锁处于写锁定状态时，其他试图加锁的线程将被阻塞; 而当读写锁处于读锁定状态时，试图以写模式加锁的线程将被阻塞，而试图以读模式加锁的线程可以正常访问。
    * 条件变量: 用于线程间同步，与互斥量一同使用。由于互斥量只有锁和解锁两种状态，当事件复杂时，需要引入其他条件来判断线程是否被阻塞，因此加入了条件变量。条件变量本身由互斥量保护，在判断条件变量前先加锁，之后判断是否满足条件(pthread_cond_wait())，如果不满足被阻塞，则锁被解除，允许其他线程改变条件。改变条件变量前同样先加锁，之后改变条件变量，最后解锁，同时唤醒其他被该条件变量阻塞的线程，其他被阻塞的线程在加锁后判断条件是否满足，不满足则继续等待。
    * 信号量: 一个非负的整数计数器，用来控制公共资源，当线程请求公共资源时，如果信号量为0，则该线程被阻塞，如果>0，则信号量减少，线程继续执行，执行完之后释放资源，信号量增加。如果只控制一个公共资源，即信号量只有1/0两种状态，那么信号量也可以模拟互斥量的功能。
* 不同进程，不同线程: 等同于进程间通信。Linux进程间通信(IPC，InterProcess Communication)主要继承Unix的进程通信方式，通过管道、信号/信号量、消息队列、共享内存以及套接字方式实现。
    * 管道: 又可分为管道(Pipe)、流管道(S_Pipe)和命名管道(Name_pipe)。管道只能在具有亲缘关系的进程间使用(父子进程)，且数据只能单向流动; 流管道允许数据双向传输; 命名管道则赋予管道名字，允许无亲缘关系的进程之间互相通信。
    * 信号/信号量: 信号量一般用于同一进程下的不同线程以及不同进程间的同步，用于控制进程/线程对共享资源的访问。信号用于通知接收信号的进程有某种事件发生，可用于进程间通信，也可发送信号给自身。信号和信号量均无法传递复杂信息。
    * 消息队列: 由消息组成的链表，容量受系统限制，克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限的缺点。
    * 共享内存: 最快的IPC形式，针对其他进程间通行方式运行效率低而设计，但需要另外的同步手段(如信号量)控制各进程对共享内存的访问。
    * 套接字: 可用于不同机器间的进程通信。

### C/C++在main()执行前会进行什么操作，如何验证
当一个C/C++程序完成编译，链接至可执行文件时，链接器将选择正确的C/C++运行库启动函数。所有的C/C++运行库启动函数所作的事情都是一样的，区别在于处理字符串的类型(ANSI或Unicode)和调用的入口点函数不同(glibc是_start，MSVC是mainCRTStartup)。启动函数将会进行以下几个步骤:
* 获取新进程完整命令行的指针
* 获取指向新进程环境变量的指针
* 初始化C/C++运行库的全局变量
* 初始化C运行库内存分配函数(malloc和calloc)和其他底层I/O例程使用的堆
* 调用所有全局和静态C++类对象的构造函数

当入口函数返回后，启动函数将调用C运行库函数exit，该函数将进行以下几个步骤:
* 调用_onexit函数所调用注册的所有函数(后进先出)
* 调用所有全局和静态C++类对象的析构函数
* 在DEBUG生成中，如果设置了_CRTDBG_LEAK_CHECK_DF标志，就通过调用_CrtDumpMemoryLeaks函数生成内存泄露报告。
* 调用操作系统的ExitProcess函数，向其传入nMainRetVal。这会导致操作系统杀死我们的进程，并设置它的退出代码

下面是一个测试程序
```
#include <iostream>
#include <cstdlib>

using namespace std;

class simpleclass{
public:
    simpleclass(){
        cout << "simpleclass construct" << endl;
    }

    ~simpleclass(){
        cout << "simpleclass destruct" << endl;
    }
};

int func1(){
    cout << "func1" << endl;
    return 0;
}

int func2(){
    cout << "func2" << endl;
    return 0;
}

int func3(){
    cout << "func3" << endl;
    return 0;
}

int func4(){
    cout << "func4" << endl;
    return 0;
}

simpleclass simpleclass1;

int main(){
    _onexit(func1);
    _onexit(func2);
    _onexit(func3);
    _onexit(func4);
    cout << "main" << endl;
}
```

该程序的输出结果为
```
simpleclass construct
main
func4
func3
func2
func1
simpleclass destruct
```

该结果显然验证了上述说明中main函数执行前步骤的第5条以及执行后步骤的第1条和第2条。

### C/C++常量指针和指针常量的区别与用法

